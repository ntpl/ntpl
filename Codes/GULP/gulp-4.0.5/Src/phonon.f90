  subroutine phonon(lprint,fc,nobsmodeptr0,nobsmode)
!
!  Calculates the phonons at a given set of k points
!
!  The block diagonal elements of derv2 must be stored, as these are
!  not recalculated in dynamic as the summing of off diagonals is no
!  longer applicable.
!
!  nkpt    = total number of k points across all structures
!  nllkpt  = number of k points for this structure
!  nlkpt   = pointer to lowest k point
!  nukpt   = pointer to upper k point
!  xkpt    = fractional x component of k point
!  ykpt    = fractional y component of k point
!  zkpt    = fractional z component of k point
!  wkpt    = weight of each k point
!  nkptcfg = configuration pointer for each k point
!  sumwkpt = sum over weights of k points
!  leigloc = local flag to indicate whether eigenvectors are 
!            to be generated for this configuration
!  fhenergy= Helmholtz free-energy
!  rtlnz   = R*T*ln(z), where z=partition function
!
!  Disk channels:
!
!   1/97 For C call to malloc eigv must be declared as real*8 -
!        this makes no difference as storage is the same and
!        complex attribute is handled in subroutines
!   3/97 Error corrected in frequencies for partially occupied
!        systems - need to reduce down atoms to proper number
!   3/97 Pointer to second derivative workspace in eigv for
!        peigen fixed.
!   3/97 Number of K points per call of dynamic reduced to 1
!        for simplicity to make free energy gradients easier.
!        With dynamic memory this nearly always happens anyway.
!   3/97 Bug storage needed for outphon fixed
!   3/97 Multiple temperatures for phonon properties added
!  11/97 Memory savings introduced for gamma point case
!        and CCALL declaration of eigv correct to complex*16
!  11/97 dervi only preserved if free energy opt, rather than
!        some general opt
!  11/97 call of outphon and writing of scratch file on channel
!        51 is now suppressed if no PDOS or dispersion curves
!        are to be generated. This also removes the need for
!        nllkpt*mcv amount of memory - when this is needed the
!        amount set used to be in error by a factor of mcv.
!  11/97 option to write out binary or text list of frequencies
!        to a file => used for Gruneisen parameter calculation
!   4/98 Use of scratch file on channel 51 has been removed in
!        favour of dynamic memory as this was causing errors on
!        DEC machines.
!   5/98 New dynamic memory allocation method in which space is
!        allocated in the main call and passed down through
!        derv2/dervi has been added for Linux where the local
!        allocation of memory appears to fail.
!   8/98 Storage of tmat eliminated as phonon should never
!        overwrite this matrix when it is still needed unless it
!        is regenerated by a call to transmat
!   8/98 Need for gamma point call removed by directly adding difference
!        between D(k)-D(0) on the diagonal blocks
!   3/99 Output of force constant matrix option added
!   6/99 Bug in partial occupancy corrected for k.ne.0 case
!   7/01 Print out of weights for K points corrected
!   7/01 Correction to weighting of K points made for multiple temperatures
!   7/01 indfrq2 incrementing corrected
!   2/02 Type of 4th argument to zhidi/zhifa corrected
!   3/02 Checking of lgamma for each K point added back
!   3/02 Non-analytic correction at gamma added
!   4/02 Polycrystalline average of gamma point n-a correction
!        added
!   5/02 K point pointer added for freq for fitting use - frq
!        array removed since no longer needed
!   7/02 Phonon calculation restricted to region 1.
!   7/02 Error in compression of region 1 atoms corrected
!   7/02 Workaround for failure of some machines to properly
!        deallocate memory from the stack added by only
!        allocating the second derivative workspace once
!   8/02 Modifications for output of eigenvectors made
!   9/02 Corrections made to non-analytic correction so that
!        direction of approach is taken from dispersion curve
!        when a K point is part of one
!   9/02 Setting of lgamma flag for K points now uses threshold
!        rather than test against zero
!   2/03 Matrix inversion accelerated through packed storage
!  11/04 Pi accessed from module
!   5/06 Mass now uses species values
!   5/07 Calculation of mean kinetic energy added
!   5/07 Partial occupancy data moved to module
!  12/07 Unused variables removed
!   4/08 Finite difference option added for dynamical matrix at
!        gamma point.
!   6/08 Non-analytical correction suppressed for finite difference
!        calculation.
!   1/09 Call to outfrc removed since it outputs incorrect forces
!   3/09 Setting of diagonal blocks skipped for finite difference case
!   3/09 dynamicn now called if this is a finite difference run
!   4/09 Control of calling outphon modified so that it occurs even if noden keyword is present
!   6/09 Integer formats increased to allow for greater numbers of K points
!   6/09 PDF changes added
!   1/10 Output of equipartition free energy added
!  10/10 Handling of nudpt/nldpt corrected so that dispersion lines are identified
!        for non-analytic correction.
!   2/12 Index for freq in equipartition free energy corrected from k to nk
!   6/12 nobsmodeptr0 and nobsmode added as input
!   6/12 Option to call either eispack or lapack eigensolvers added
!   6/12 Allocation of eigr modified for case when lapack eigensolver is being used
!   6/12 Thermal conductivity calculation added
!   6/12 Calls to phoncopy routines changed to add extra argument
!
!  Conditions of use:
!
!  GULP is available free of charge to academic institutions
!  and non-commerical establishments only. Copies should be
!  obtained from the author only and should not be distributed
!  in any form by the user to a third party without the express
!  permission of the author. This notice applies to all parts
!  of the program, except any library routines which are
!  distributed with the code for completeness. All rights for
!  such routines remain with the original distributor.
!
!  No claim is made that this program is free from errors and
!  no liability will be accepted for any loss or damage that
!  may result. The user is responsible for checking the validity
!  of their results.
!
!  Copyright Curtin University 2012
!
!  Julian Gale, NRI, Curtin University, June 2012
!
  use configurations
  use constants
  use control
  use current
  use derivatives
  use dispersion
  use element
  use files
  use frequencies
  use general
  use gulp_cml,        only : lcml
  use gulp_cml_phonon, only : gulp_cml_startPhonons, gulp_cml_outPDF
  use gulp_cml_phonon, only : gulp_cml_addKPoint, gulp_cml_endPhonons, gulp_cml_PDFstats
  use iochannels
  use ksample
  use m_pdf,           only : closepdfphonon, pdfsetup
  use m_pdfneutron
  use maths,           only : leispack_eigensolve
  use observables,     only : fobsmodefreq
  use parallel
  use partial
  use projectdos
  use properties
  use species,      only : massspec, natspec, ntypspec
  use shell
  use times
  implicit none
!
!  Passed variables
!
  integer(i4),  intent(in)                          :: nobsmodeptr0  ! Pointer to first observable mode - 1
  integer(i4),  intent(in)                          :: nobsmode      ! Number of observable modes if fitting run
  logical,      intent(in)                          :: lprint        ! If true then output results
  real(dp),     intent(in)                          :: fc            ! Internal energy
!
!  Local variables
!
  character(len=5)                                  :: lab1
  complex(dpc), dimension(:),     allocatable       :: ctmp
  integer(i4)                                       :: i
  integer(i4)                                       :: ifail
  integer(i4)                                       :: ii
  integer(i4)                                       :: indi
  integer(i4)                                       :: indii
  integer(i4)                                       :: indj
  integer(i4)                                       :: indjj
  integer(i4)                                       :: indl
  integer(i4)                                       :: inert(3)
  integer(i4),  dimension(:),     allocatable       :: ipivot
  integer(i4)                                       :: j
  integer(i4)                                       :: jj
  integer(i4)                                       :: job
  integer(i4)                                       :: k
  integer(i4)                                       :: kk
  integer(i4),  dimension(:),     allocatable       :: kpvt
  integer(i4)                                       :: l
  integer(i4)                                       :: maxlim
  integer(i4)                                       :: mcv
  integer(i4)                                       :: mint
  integer(i4)                                       :: mir
  integer(i4)                                       :: mis
  integer(i4)                                       :: mjr
  integer(i4)                                       :: mjs
  integer(i4)                                       :: msv
  integer(i4)                                       :: nd
  integer(i4)                                       :: nf
  integer(i4)                                       :: nfitmode
  integer(i4)                                       :: nk
  integer(i4)                                       :: nldpt
  integer(i4)                                       :: nlkpt
  integer(i4)                                       :: nllkpt
  integer(i4)                                       :: nobm
  integer(i4)                                       :: np
  integer(i4)                                       :: np_nlkpt
  integer(i4)                                       :: np_procs
  integer(i4)                                       :: nphonat
  integer(i4)                                       :: nphonatb
  integer(i4)                                       :: nphonatc
  integer(i4),  dimension(:),     allocatable       :: nphonatptr
  integer(i4)                                       :: nphonats
  integer(i4)                                       :: nri
  integer(i4)                                       :: nrj
  integer(i4)                                       :: nsi
  integer(i4)                                       :: nt
  integer(i4)                                       :: ntmax
  integer(i4)                                       :: nudpt
  integer(i4)                                       :: nukpt
  integer(i4)                                       :: status
  logical                                           :: lcmlloc
  logical                                           :: ldendisp
  logical                                           :: leigloc
  logical                                           :: lfirst1
  logical                                           :: lfound
  logical                                           :: lgamma
  logical                                           :: lgammaonly
  logical                                           :: lnonanal
  logical                                           :: lnoanald2loc
  logical                                           :: lnozero
  logical                                           :: lpartofdisp
  logical                                           :: lprinloc
  logical                                           :: ltemprop
  real(dp),     dimension(:),     allocatable       :: averfreq
  real(dp)                                          :: bornkloc(3)
  real(dp)                                          :: cmfact
  real(dp)                                          :: cputime
  real(dp)                                          :: cv2
  real(dp)                                          :: det(2)
  real(dp)                                          :: diff
  real(dp)                                          :: eigcomp
  real(dp),     dimension(:),     allocatable       :: eigr
  real(dp)                                          :: eigreal
  real(dp)                                          :: ent2
  real(dp)                                          :: factor
  real(dp)                                          :: fe_equipartition
  real(dp)                                          :: fentropy
  real(dp)                                          :: fhenergy
  real(dp)                                          :: finternal
  real(dp)                                          :: freqmin
  real(dp)                                          :: fscale
  real(dp)                                          :: kinenergy
  real(dp),     dimension(:),     allocatable       :: meanKEperatom
  real(dp),     dimension(:,:,:), allocatable       :: oscstrength
  real(dp)                                          :: phi
  real(dp)                                          :: phistep
  real(dp)                                          :: projectionfactor
  real(dp)                                          :: qfrac(3)
  real(dp)                                          :: rkt
  real(dp)                                          :: rmassi
  real(dp)                                          :: rmode
  real(dp)                                          :: rnokpt
  real(dp)                                          :: rtlnz
  real(dp),     dimension(:),     allocatable       :: rtmp2
  real(dp),     dimension(:),     allocatable       :: savefreq
  real(dp),     dimension(:,:),   allocatable       :: savederv2
  real(dp),     dimension(:,:),   allocatable       :: Sij
  real(dp)                                          :: sumwkpt
  real(dp)                                          :: t1
  real(dp)                                          :: t1i
  real(dp)                                          :: t1t
  real(dp)                                          :: t2
  real(dp)                                          :: t2i
  real(dp)                                          :: t2t
  real(dp)                                          :: tem
  real(dp)                                          :: theta
  real(dp)                                          :: thetastep
  real(dp)                                          :: trm
  real(dp)                                          :: trm1
  real(dp)                                          :: trmcv
  real(dp)                                          :: trmen
  real(dp)                                          :: trmfe
  real(dp)                                          :: trmfe_eq
  real(dp)                                          :: trmke
  real(dp)                                          :: trmzp
  real(dp),     dimension(:),     allocatable       :: w1
  real(dp),     dimension(:),     allocatable       :: w2
  real(dp),     dimension(:),     allocatable       :: w3
  real(dp)                                          :: weightpt
  real(dp)                                          :: wi
  real(dp)                                          :: wk
  real(dp)                                          :: wr
  real(dp)                                          :: xkt
  real(dp)                                          :: ykt
  real(dp)                                          :: zkt
  real(dp)                                          :: zpe
!
  t1t = cputime()
!
!  Set logicals
!
  leigloc = (leigen.or.leig)
  if ((nprojcfg(ncf)-nprojdef(ncf)).gt.0) leigloc = .true.
  if (.not.lprint) leigloc = .false.
  if (lomega(ncf)) leigloc = .true.
  if (nbornstep(ncf).gt.0) leigloc = .true.
  if (lmeanke) leigloc = .true.
  if (nobsmode.gt.0) leigloc = .true.
  if (lthermal) leigloc = .true.
  lprinloc = (lprint.and.ioproc)
  lnozero  = (index(keyword,'noze').ne.0)
  ltemprop = (temperature.gt.1.0d-6.or.ntemperaturestep.gt.0)
  lnonanal = (index(keyword,'nono').eq.0.and.ndim.eq.3.and..not.leem.and..not.lnoanald2)
  lnoanald2loc = (lnoanald2)
!
!  CML phonon output
!
  lcmlloc = (lcml.and.lfreqout)
  if (lcmlloc) call gulp_cml_startPhonons
!
!  Set constants
!
  fscale = sqrt(1.0d23*evtoj*avogadro)
  fscale = fscale/(2.0_dp*pi*speedl)
!
!  Set flag as to whether PDOS or dispersion curves
!  are to be produced
!
  if ((lphono.or.ndline.gt.0.or.index(keyword,'node').eq.0)) then
    ldendisp = lprint
  else
    ldendisp = .false.
  endif
!
!  Work out number of k points for this structure.
!
!  Requires k points to be sorted such that all points
!  relating a given structure are consecutive.
!  
  nlkpt = 0
  do i = 1,nkpt
    nk = nkptcfg(i)
    if (nlkpt.eq.0.and.nk.eq.ncf) nlkpt = i
    if (nk.eq.ncf) nukpt = i
  enddo
!
!  No k points found for current structure, so return
!
  if (nlkpt.eq.0) return
  nllkpt = nukpt - nlkpt + 1
!     
!  Work out lower and upper dispersion lines for this configuration
!     
  nldpt = 0
  if (ndline.gt.0) then
    do i = 1,ndline 
      nd = ndispcfg(i)
      if (nldpt.eq.0.and.nd.eq.ncf) nldpt = i
      if (nd.eq.ncf) nudpt = i
    enddo
  else
    nudpt = -1
  endif
!************************************************
!  Find number of atoms for phonon calculation  *
!************************************************
  allocate(nphonatptr(numat),stat=status)
  if (status/=0) call outofmemory('phonon','nphonatptr')
  if (ndim.eq.2) then
!
!  nphonat  = number of atoms involved in phonon calculation
!  nphonatb = number of breathing shells involved in phonon calculation
!  nphonatc = number of cores involved in phonon calculation
!  nphonats = number of shells involved in phonon calculation
!  nphonatptr = pointer from nphonat to numat reference
!
    nphonat = 0
    nphonatb = 0
    nphonatc = 0
    nphonats = 0
    do i = 1,numat
      if (nregionno(nsft+nrelat(i)).eq.1) then
        nphonat = nphonat + 1
        if (nat(i).gt.maxele) then
          nphonats = nphonats + 1
        else
          nphonatc = nphonatc + 1
        endif
        nphonatptr(nphonat) = i
        if (lbsmat(nsft+nrelat(i))) then
          nphonatb = nphonatb + 1
        endif
      endif
    enddo
  else
    nphonat = numat
    nphonatb = 0
    do i = 1,numat
      nphonatptr(i) = i
      if (lbsmat(nsft+nrelat(i))) then
        nphonatb = nphonatb + 1
      endif
    enddo
    nphonatc = ncore
    nphonats = nshell
  endif
!
!  Allocate local pointer arrays
!
  allocate(meanKEperatom(numat),stat=status)
  if (status/=0) call outofmemory('phonon','meanKEperatom')
  lpocc = (nsfoc+ncfoc.ne.nphonat)
!
!  Calculate a few constants to do with the size of the problem
!
  mint = 3*nphonat
  maxlim = mint
  if (nbsmat.gt.0) maxlim = maxlim + nphonat
  msv = 3*nsfoc + nbfoc
  mcv = 3*ncfoc
!
!  Check that maxd2 is greater than or equal to mcv
!
  if (maxd2.lt.mcv) then
    maxd2 = mcv
    call changemaxd2
  endif
!
!  Allocate array to hold oscillator strengths if needed
!
  if (leigloc) then
    allocate(savefreq(mcv),stat=status)
    if (status/=0) call outofmemory('phonon','savefreq')
    allocate(oscstrength(3,3,mcv),stat=status)
    if (status/=0) call outofmemory('phonon','oscstrength')
  endif
!
!  Allocate array for thermal conductivity if needed
!
  if (lthermal) then
    allocate(Sij(mcv,mcv),stat=status)
    if (status/=0) call outofmemory('phonon','Sij')
  endif
!
!  Initialise thermodynamic properties
!
  zpe = 0.0_dp
  entropy = 0.0_dp
  fentropy = 0.0_dp
  fhenergy = 0.0_dp
  finternal = 0.0_dp
  kinenergy = 0.0_dp
  rtlnz = 0.0_dp
  cv = 0.0_dp
  fe_equipartition = 0.0_dp
  rkt = boltz*temperature
!
!  If mean KE per atom is requested then initialise array to zero
!
  if (lmeanke) then
    meanKEperatom(1:ncfoc) = 0.0_dp
  endif
!
!  Calculate inversion square root of masses
!
!  Now modified to handle partial occupancies
!
  do i = 1,ncfoc
    mass(i) = 0.0_dp
  enddo
  do i = 1,nphonatc
    ii = iocptr(i)
    nsi = nspecptr(nrelat(nphonatptr(i)))
    rmassi = massspec(nsi)*occuf(nphonatptr(i))
    if (natspec(nsi).le.maxele.and.abs(rmassi).lt.1.0d-12) then
      call label(natspec(nsi),ntypspec(nsi),lab1)
      call outerror('mass of species '//lab1//' is zero',0_i4)
      goto 999
    endif
    mass(ii) = mass(ii) + rmassi
  enddo
  do i = 1,ncfoc
    if (mass(i).eq.0.0_dp) then
      call outerror('site has total mass of zero in phonon',0_i4)
      call stopnow('phonon')
    endif
    rmass(i) = 1.0_dp/sqrt(mass(i))
  enddo
  if (.not.lnoanald2loc.and..not.lfinitediff) then
!
!  Store diagonal blocks in derv3 to avoid recalculation
!
    do i = 1,nphonat
      indi = 3*(nphonatptr(i)-1)
      derv3(indi+1,1) = derv2(indi+1,indi+1)
      derv3(indi+2,1) = derv2(indi+2,indi+1)
      derv3(indi+3,1) = derv2(indi+3,indi+1)
      derv3(indi+1,2) = derv2(indi+1,indi+2)
      derv3(indi+2,2) = derv2(indi+2,indi+2)
      derv3(indi+3,2) = derv2(indi+3,indi+2)
      derv3(indi+1,3) = derv2(indi+1,indi+3)
      derv3(indi+2,3) = derv2(indi+2,indi+3)
      derv3(indi+3,3) = derv2(indi+3,indi+3)
    enddo
    if (nbsmat.gt.0) then
      do i = 1,numat
        indi = mint + i
        derv3(indi,1) = derv2(indi,indi)
      enddo
    endif
  endif
!
!  Sum up k point weights and check for gamma point
!
  lgamma = .false.
  sumwkpt = 0.0_dp
  do i = nlkpt,nukpt
    sumwkpt = sumwkpt + wkpt(i)
    if (xkpt(i).eq.0.0_dp.and.ykpt(i).eq.0.0_dp.and.zkpt(i).eq.0.0_dp) then
      lgamma = .true.
    endif
  enddo
!
!  Is the gamma point the only K point?
!
  lgammaonly = (lgamma.and.nllkpt.eq.1)
!
!  If this is a finite difference second derivative run and there is a non-gamma k-point then stop.
!
  if ((lfinitediff.or.lnoanald2loc).and..not.lgammaonly) then
    call outerror('Finite difference phonons only allowed for gamma point',0_i4)
    call stopnow('phonon')
  endif
!
  rnokpt = 1.0_dp/sumwkpt
!
!  Ensure we have k vectors
!
  if (ndim.eq.3) then
    call kvector3D
  elseif (ndim.eq.2) then
    call kvector2D
  elseif (ndim.eq.1) then
    call kvector1D
  endif
!
!  Output phonon header
!
  if (lprinloc) then
    write(ioout,'(/,''  Phonon Calculation : '',/)')
    if (lgamma.and.lnonanal) then
      if (nbornstep(ncf).gt.0) then
        write(ioout,'(''  Number of angular steps for n-a correction at gamma = '',i6,/)') nbornstep(ncf)
      else
        write(ioout,'(''  K direction for n-a correction at gamma ='',3(1x,f8.5),/)') bornk(1,ncf),bornk(2,ncf),bornk(3,ncf)
      endif
    endif
    write(ioout,'(''  Number of k points for this configuration = '',i8,/)')(nukpt-nlkpt+1)
    write(ioout,'(''--------------------------------------------------------------------------------'')')
  endif
!****************************************************
!  If frequencies are to be written to a permanent  *
!  file then open with the correct type here        *
!****************************************************
  if (lfrq.and.ioproc) then
    if (index(freqfile,' ').ne.1) then
      if (lfrqbin) then
        open(51,file=freqfile,form='unformatted',status='unknown')
      else
        open(52,file=freqfile,status='unknown')
      endif
    else
      if (lfrqbin) then
        open(51,form='unformatted',status='unknown')
      else
        open(52,status='unknown')
      endif
    endif
  endif
!*******************************************************
!  Open eigenvector file if required and write header  *
!*******************************************************
  if (leig.and.ioproc) then
    open(53,file=eigfile,status='unknown',form='formatted')
    write(53,'(i6)') nphonatc
    do i = 1,nphonatc
      ii = nphonatptr(i)
      write(53,'(i3,1x,3(f15.6,1x))') nat(ii),xclat(ii),yclat(ii),zclat(ii)
    enddo
    write(53,'(i6)') nllkpt
    write(53,'(i6)') 3*nphonatc
  endif
!************************************************
!  Allocate second derivative workspace memory  *
!************************************************
  if (leigloc) then
    if (lgammaonly.and.nbornstep(ncf).eq.0) then
      allocate(eigr(maxd2*maxd2),stat=status)
    else
      allocate(eigr(2*maxd2*maxd2),stat=status)
    endif
    if (status/=0) call outofmemory('phonon','eigr')
    if (nbornstep(ncf).gt.0.and.lnonanal) then
      allocate(savederv2(mcv,mcv),stat=status)
      if (status/=0) call outofmemory('phonon','savederv2')
    endif
  else
    if (leispack_eigensolve) then
      if (msv.gt.0) then
        if (lgammaonly) then
          allocate(eigr(msv*msv),stat=status)
        else
          allocate(eigr(2*msv*msv),stat=status)
        endif
      else
        allocate(eigr(1),stat=status)
      endif
    elseif (.not.lgammaonly) then
      allocate(eigr(2*maxd2*mcv),stat=status)
    elseif (msv.gt.0) then
      allocate(eigr(msv*(msv+1)/2),stat=status)
    else
      allocate(eigr(1),stat=status)
    endif
    if (status/=0) call outofmemory('phonon','eigr')
  endif
!***********************
!  Setup PDF Variables *
!***********************
  if (lpdf) then
    call setuppdfphonon(nllkpt,mcv,nphonatc,nphonatptr,ncf)
  endif
!***********************
!  Loop over k points  *
!***********************
  np_nlkpt = nlkpt
  np_procs = 1_i4
  do k = np_nlkpt,nukpt,np_procs
    if (lpdf) then
!
!  Store k point information in PDF module
!
      call setcurk(k,lallk=.true.)
    endif
    xkt = xkpt(k)
    ykt = ykpt(k)
    zkt = zkpt(k)
    wk = wkpt(k)*rnokpt
    diff = abs(xkt) + abs(ykt) + abs(zkt)
    lgamma = (diff.lt.1.0d-10)
!
    if (lfreqout.and.lprinloc) then
      write(ioout,'(''  K point '',i6,'' = '',3f10.6,''  Weight = '',f8.3)') k,xkt,ykt,zkt,wk
      write(ioout,'(''--------------------------------------------------------------------------------'')')
    endif
!
!  Write K point header to file if required
!
    if (leig.and.ioproc) then
      write(53,'(''K point at '',3f10.6,'' in BZ '')') xkt,ykt,zkt
    endif
!
!  Generate phased second derivatives
!
    if (lnoanald2loc.or.lfinitediff) then
      call dynamicn
    else
      call dynamic(k)
    endif
!
    if (.not.lnoanald2loc.and..not.lfinitediff) then
!
!  Include diagonal blocks, stored in derv3
!
      do i = 1,nphonat
        indi = 3*(nphonatptr(i) - 1)
        derv2(indi+1,indi+1) = derv2(indi+1,indi+1) + derv3(indi+1,1)
        derv2(indi+2,indi+1) = derv2(indi+2,indi+1) + derv3(indi+2,1)
        derv2(indi+3,indi+1) = derv2(indi+3,indi+1) + derv3(indi+3,1)
        derv2(indi+1,indi+2) = derv2(indi+1,indi+2) + derv3(indi+1,2)
        derv2(indi+2,indi+2) = derv2(indi+2,indi+2) + derv3(indi+2,2)
        derv2(indi+3,indi+2) = derv2(indi+3,indi+2) + derv3(indi+3,2)
        derv2(indi+1,indi+3) = derv2(indi+1,indi+3) + derv3(indi+1,3)
        derv2(indi+2,indi+3) = derv2(indi+2,indi+3) + derv3(indi+2,3)
        derv2(indi+3,indi+3) = derv2(indi+3,indi+3) + derv3(indi+3,3)
      enddo
      if (nbsmat.gt.0) then
        do i = 1,nphonat
          indi = mint + nphonatptr(i)
          derv2(indi,indi) = derv2(indi,indi) + derv3(indi,1)
        enddo
      endif
    endif
!*****************************************************************
!  Compress second derivatives according to partial occupancies  *
!*****************************************************************
    if (lpocc) then
      ncsfoc = ncfoc + nsfoc
!
!  Pass 1 : shift j direction
!
      do i = 1,numat
        indi = 3*(i-1)
        do j = 1,ncsfoc
          indj = 3*(j-1)
          lfirst1 = .true.
          do l = 1,nphonat
            if (iocptr(l).eq.j) then
              indl = 3*(nphonatptr(l)-1)
              if (lfirst1) then
!
!  If the first occurance overwrite block
!
                derv2(indj+1,indi+1) = derv2(indl+1,indi+1)
                derv2(indj+2,indi+1) = derv2(indl+2,indi+1)
                derv2(indj+3,indi+1) = derv2(indl+3,indi+1)
                derv2(indj+1,indi+2) = derv2(indl+1,indi+2)
                derv2(indj+2,indi+2) = derv2(indl+2,indi+2)
                derv2(indj+3,indi+2) = derv2(indl+3,indi+2)
                derv2(indj+1,indi+3) = derv2(indl+1,indi+3)
                derv2(indj+2,indi+3) = derv2(indl+2,indi+3)
                derv2(indj+3,indi+3) = derv2(indl+3,indi+3)
                if (.not.lgamma) then
                  dervi(indj+1,indi+1) = dervi(indl+1,indi+1)
                  dervi(indj+2,indi+1) = dervi(indl+2,indi+1)
                  dervi(indj+3,indi+1) = dervi(indl+3,indi+1)
                  dervi(indj+1,indi+2) = dervi(indl+1,indi+2)
                  dervi(indj+2,indi+2) = dervi(indl+2,indi+2)
                  dervi(indj+3,indi+2) = dervi(indl+3,indi+2)
                  dervi(indj+1,indi+3) = dervi(indl+1,indi+3)
                  dervi(indj+2,indi+3) = dervi(indl+2,indi+3)
                  dervi(indj+3,indi+3) = dervi(indl+3,indi+3)
                endif
                lfirst1 = .false.
              else
!
!  Subsequent add to block
!
                derv2(indj+1,indi+1) = derv2(indj+1,indi+1) + derv2(indl+1,indi+1)
                derv2(indj+2,indi+1) = derv2(indj+2,indi+1) + derv2(indl+2,indi+1)
                derv2(indj+3,indi+1) = derv2(indj+3,indi+1) + derv2(indl+3,indi+1)
                derv2(indj+1,indi+2) = derv2(indj+1,indi+2) + derv2(indl+1,indi+2)
                derv2(indj+2,indi+2) = derv2(indj+2,indi+2) + derv2(indl+2,indi+2)
                derv2(indj+3,indi+2) = derv2(indj+3,indi+2) + derv2(indl+3,indi+2)
                derv2(indj+1,indi+3) = derv2(indj+1,indi+3) + derv2(indl+1,indi+3)
                derv2(indj+2,indi+3) = derv2(indj+2,indi+3) + derv2(indl+2,indi+3)
                derv2(indj+3,indi+3) = derv2(indj+3,indi+3) + derv2(indl+3,indi+3)
                if (.not.lgamma) then
                  dervi(indj+1,indi+1) = dervi(indj+1,indi+1) + dervi(indl+1,indi+1)
                  dervi(indj+2,indi+1) = dervi(indj+2,indi+1) + dervi(indl+2,indi+1)
                  dervi(indj+3,indi+1) = dervi(indj+3,indi+1) + dervi(indl+3,indi+1)
                  dervi(indj+1,indi+2) = dervi(indj+1,indi+2) + dervi(indl+1,indi+2)
                  dervi(indj+2,indi+2) = dervi(indj+2,indi+2) + dervi(indl+2,indi+2)
                  dervi(indj+3,indi+2) = dervi(indj+3,indi+2) + dervi(indl+3,indi+2)
                  dervi(indj+1,indi+3) = dervi(indj+1,indi+3) + dervi(indl+1,indi+3)
                  dervi(indj+2,indi+3) = dervi(indj+2,indi+3) + dervi(indl+2,indi+3)
                  dervi(indj+3,indi+3) = dervi(indj+3,indi+3) + dervi(indl+3,indi+3)
                endif
              endif
            endif
          enddo
        enddo
      enddo
!
!  Pass 2 : shift i direction
!
      do i = 1,ncsfoc
        indi = 3*(i-1)
        do j = 1,ncsfoc
          indj = 3*(j-1)
          lfirst1 = .true.
          do l = 1,nphonat
            if (iocptr(l).eq.j) then
              indl = 3*(nphonatptr(l)-1)
              if (lfirst1) then
!
!  If the first occurance overwrite block
!
                derv2(indi+1,indj+1) = derv2(indi+1,indl+1)
                derv2(indi+2,indj+1) = derv2(indi+2,indl+1)
                derv2(indi+3,indj+1) = derv2(indi+3,indl+1)
                derv2(indi+1,indj+2) = derv2(indi+1,indl+2)
                derv2(indi+2,indj+2) = derv2(indi+2,indl+2)
                derv2(indi+3,indj+2) = derv2(indi+3,indl+2)
                derv2(indi+1,indj+3) = derv2(indi+1,indl+3)
                derv2(indi+2,indj+3) = derv2(indi+2,indl+3)
                derv2(indi+3,indj+3) = derv2(indi+3,indl+3)
                if (.not.lgamma) then
                  dervi(indi+1,indj+1) = dervi(indi+1,indl+1)
                  dervi(indi+2,indj+1) = dervi(indi+2,indl+1)
                  dervi(indi+3,indj+1) = dervi(indi+3,indl+1)
                  dervi(indi+1,indj+2) = dervi(indi+1,indl+2)
                  dervi(indi+2,indj+2) = dervi(indi+2,indl+2)
                  dervi(indi+3,indj+2) = dervi(indi+3,indl+2)
                  dervi(indi+1,indj+3) = dervi(indi+1,indl+3)
                  dervi(indi+2,indj+3) = dervi(indi+2,indl+3)
                  dervi(indi+3,indj+3) = dervi(indi+3,indl+3)
                endif
                lfirst1 = .false.
              else
!
!  Subsequent add to block
!
                derv2(indi+1,indj+1) = derv2(indi+1,indj+1) + derv2(indi+1,indl+1)
                derv2(indi+2,indj+1) = derv2(indi+2,indj+1) + derv2(indi+2,indl+1)
                derv2(indi+3,indj+1) = derv2(indi+3,indj+1) + derv2(indi+3,indl+1)
                derv2(indi+1,indj+2) = derv2(indi+1,indj+2) + derv2(indi+1,indl+2)
                derv2(indi+2,indj+2) = derv2(indi+2,indj+2) + derv2(indi+2,indl+2)
                derv2(indi+3,indj+2) = derv2(indi+3,indj+2) + derv2(indi+3,indl+2)
                derv2(indi+1,indj+3) = derv2(indi+1,indj+3) + derv2(indi+1,indl+3)
                derv2(indi+2,indj+3) = derv2(indi+2,indj+3) + derv2(indi+2,indl+3)
                derv2(indi+3,indj+3) = derv2(indi+3,indj+3) + derv2(indi+3,indl+3)
                if (.not.lgamma) then
                  dervi(indi+1,indj+1) = dervi(indi+1,indj+1) + dervi(indi+1,indl+1)
                  dervi(indi+2,indj+1) = dervi(indi+2,indj+1) + dervi(indi+2,indl+1)
                  dervi(indi+3,indj+1) = dervi(indi+3,indj+1) + dervi(indi+3,indl+1)
                  dervi(indi+1,indj+2) = dervi(indi+1,indj+2) + dervi(indi+1,indl+2)
                  dervi(indi+2,indj+2) = dervi(indi+2,indj+2) + dervi(indi+2,indl+2)
                  dervi(indi+3,indj+2) = dervi(indi+3,indj+2) + dervi(indi+3,indl+2)
                  dervi(indi+1,indj+3) = dervi(indi+1,indj+3) + dervi(indi+1,indl+3)
                  dervi(indi+2,indj+3) = dervi(indi+2,indj+3) + dervi(indi+2,indl+3)
                  dervi(indi+3,indj+3) = dervi(indi+3,indj+3) + dervi(indi+3,indl+3)
                endif
              endif
            endif
          enddo
        enddo
      enddo
    elseif (numat.ne.nphonat) then
!*********************************************************************
!  Compress full second derivatives down to region 1 only if needed  *
!*********************************************************************
      do i = 1,nphonat
        indi  = 3*(i-1)
        indii = 3*(nphonatptr(i)-1)
        do j = 1,nphonat
          indj  = 3*(j-1)
          indjj = 3*(nphonatptr(j)-1)
          derv2(indj+1,indi+1) = derv2(indjj+1,indii+1)
          derv2(indj+2,indi+1) = derv2(indjj+2,indii+1)
          derv2(indj+3,indi+1) = derv2(indjj+3,indii+1)
          derv2(indj+1,indi+2) = derv2(indjj+1,indii+2)
          derv2(indj+2,indi+2) = derv2(indjj+2,indii+2)
          derv2(indj+3,indi+2) = derv2(indjj+3,indii+2)
          derv2(indj+1,indi+3) = derv2(indjj+1,indii+3)
          derv2(indj+2,indi+3) = derv2(indjj+2,indii+3)
          derv2(indj+3,indi+3) = derv2(indjj+3,indii+3)
          if (.not.lgamma) then
            dervi(indj+1,indi+1) = dervi(indjj+1,indii+1)
            dervi(indj+2,indi+1) = dervi(indjj+2,indii+1)
            dervi(indj+3,indi+1) = dervi(indjj+3,indii+1)
            dervi(indj+1,indi+2) = dervi(indjj+1,indii+2)
            dervi(indj+2,indi+2) = dervi(indjj+2,indii+2)
            dervi(indj+3,indi+2) = dervi(indjj+3,indii+2)
            dervi(indj+1,indi+3) = dervi(indjj+1,indii+3)
            dervi(indj+2,indi+3) = dervi(indjj+2,indii+3)
            dervi(indj+3,indi+3) = dervi(indjj+3,indii+3)
          endif
        enddo
      enddo
    endif
!**************************************************************
!  Compress second derivative matrix w.r.t. breathing shells  *
!**************************************************************
    if (nbsmat.gt.0) then
      if (lpocc) then
!
!  Partial occupancy
!
!  Pass 1 : reduce numat to ncfoc+nsfoc & numat to nbfoc in 1D
!
        mis = mint
        mjs = mint
        mir = 3*ncsfoc
        mjr = 3*ncsfoc
        do i = 1,numat
          do j = 1,ncsfoc
            indj = 3*(j-1)
            lfirst1 = .true.
            do l = 1,numat
              if (iocptr(l).eq.j) then
                indl = 3*(l-1)
                if (lfirst1) then
!
!  First occurance -> overwrite block
!
                  derv2(indj+1,mis+i) = derv2(indl+1,mis+i)
                  derv2(indj+2,mis+i) = derv2(indl+2,mis+i)
                  derv2(indj+3,mis+i) = derv2(indl+3,mis+i)
                  derv2(mis+i,indj+1) = derv2(mis+i,indl+1)
                  derv2(mis+i,indj+2) = derv2(mis+i,indl+2)
                  derv2(mis+i,indj+3) = derv2(mis+i,indl+3)
                  if (.not.lgamma) then
                    dervi(indj+1,mis+i) = dervi(indl+1,mis+i)
                    dervi(indj+2,mis+i) = dervi(indl+2,mis+i)
                    dervi(indj+3,mis+i) = dervi(indl+3,mis+i)
                    dervi(mis+i,indj+1) = dervi(mis+i,indl+1)
                    dervi(mis+i,indj+2) = dervi(mis+i,indl+2)
                    dervi(mis+i,indj+3) = dervi(mis+i,indl+3)
                  endif
                  lfirst1 = .false.
                else
!
!  Second occurance -> add terms on
!
                  derv2(indj+1,mis+i) = derv2(indj+1,mis+i) + derv2(indl+1,mis+i)
                  derv2(indj+2,mis+i) = derv2(indj+2,mis+i) + derv2(indl+2,mis+i)
                  derv2(indj+3,mis+i) = derv2(indj+3,mis+i) + derv2(indl+3,mis+i)
                  derv2(mis+i,indj+1) = derv2(mis+i,indj+1) + derv2(mis+i,indl+1)
                  derv2(mis+i,indj+2) = derv2(mis+i,indj+2) + derv2(mis+i,indl+2)
                  derv2(mis+i,indj+3) = derv2(mis+i,indj+3) + derv2(mis+i,indl+3)
                  if (.not.lgamma) then
                    dervi(indj+1,mis+i) = dervi(indj+1,mis+i) + dervi(indl+1,mis+i)
                    dervi(indj+2,mis+i) = dervi(indj+2,mis+i) + dervi(indl+2,mis+i)
                    dervi(indj+3,mis+i) = dervi(indj+3,mis+i) + dervi(indl+3,mis+i)
                    dervi(mis+i,indj+1) = dervi(mis+i,indj+1) + dervi(mis+i,indl+1)
                    dervi(mis+i,indj+2) = dervi(mis+i,indj+2) + dervi(mis+i,indl+2)
                    dervi(mis+i,indj+3) = dervi(mis+i,indj+3) + dervi(mis+i,indl+3)
                  endif
                endif
              endif
            enddo
          enddo
          do j = 1,nbfoc
            lfirst1 = .true.
            do l = 1,numat
              if (ibocptr(l).eq.j) then
                if (lfirst1) then
                  derv2(mjr+j,mis+i) = derv2(mjs+l,mis+i)
                  if (.not.lgamma) then
                    dervi(mjr+j,mis+i) = dervi(mjs+l,mis+i)
                  endif
                  lfirst1 = .false.
                else
                  derv2(mjr+j,mis+i) = derv2(mjr+j,mis+i) + derv2(mjs+l,mis+i)
                  if (.not.lgamma) then
                    dervi(mjr+j,mis+i) = dervi(mjr+j,mis+i) + dervi(mjs+l,mis+i)
                  endif
                endif
              endif
            enddo
          enddo
        enddo
!
!  Pass 2 : reduce numat to nbfoc in remaining directions
!
        do i = 1,ncsfoc
          indi = 3*(i-1)
          do j = 1,nbfoc
            lfirst1 = .true.
            do l = 1,numat
              if (ibocptr(l).eq.j) then
                if (lfirst1) then
!
!  First occurance -> overwrite block
!
                  derv2(indi+1,mir+j) = derv2(indi+1,mis+l)
                  derv2(indi+2,mir+j) = derv2(indi+2,mis+l)
                  derv2(indi+3,mir+j) = derv2(indi+3,mis+l)
                  derv2(mir+j,indi+1) = derv2(mis+l,indi+1)
                  derv2(mir+j,indi+2) = derv2(mis+l,indi+2)
                  derv2(mir+j,indi+3) = derv2(mis+l,indi+3)
                  if (.not.lgamma) then
                    dervi(indi+1,mir+j) = dervi(indi+1,mis+l)
                    dervi(indi+2,mir+j) = dervi(indi+2,mis+l)
                    dervi(indi+3,mir+j) = dervi(indi+3,mis+l)
                    dervi(mir+j,indi+1) = dervi(mis+l,indi+1)
                    dervi(mir+j,indi+2) = dervi(mis+l,indi+2)
                    dervi(mir+j,indi+3) = dervi(mis+l,indi+3)
                  endif
                  lfirst1 = .false.
                else
!
!  Second occurance -> add terms on
!
                  derv2(indi+1,mir+j) = derv2(indi+1,mir+j) + derv2(indi+1,mis+l)
                  derv2(indi+2,mir+j) = derv2(indi+2,mir+j) + derv2(indi+2,mis+l)
                  derv2(indi+3,mir+j) = derv2(indi+3,mir+j) + derv2(indi+3,mis+l)
                  derv2(mir+j,indi+1) = derv2(mir+j,indi+1) + derv2(mis+l,indi+1)
                  derv2(mir+j,indi+2) = derv2(mir+j,indi+2) + derv2(mis+l,indi+2)
                  derv2(mir+j,indi+3) = derv2(mir+j,indi+3) + derv2(mis+l,indi+3)
                  if (.not.lgamma) then
                    dervi(indi+1,mir+j) = dervi(indi+1,mir+j) + dervi(indi+1,mis+l)
                    dervi(indi+2,mir+j) = dervi(indi+2,mir+j) + dervi(indi+2,mis+l)
                    dervi(indi+3,mir+j) = dervi(indi+3,mir+j) + dervi(indi+3,mis+l)
                    dervi(mir+j,indi+1) = dervi(mir+j,indi+1) + dervi(mis+l,indi+1)
                    dervi(mir+j,indi+2) = dervi(mir+j,indi+2) + dervi(mis+l,indi+2)
                    dervi(mir+j,indi+3) = dervi(mir+j,indi+3) + dervi(mis+l,indi+3)
                  endif
                endif
              endif
            enddo
          enddo
        enddo
        do i = 1,nbfoc
          do j = 1,nbfoc
            lfirst1 = .true.
            do l = 1,numat
              if (ibocptr(l).eq.j) then
                if (lfirst1) then
                  derv2(mjr+i,mir+j) = derv2(mjr+i,mis+l)
                  if (.not.lgamma) then
                    dervi(mjr+i,mir+j) = dervi(mjr+i,mis+l)
                  endif
                  lfirst1 = .false.
                else
                  derv2(mjr+i,mir+j) = derv2(mjr+i,mir+j) + derv2(mjr+i,mis+l)
                  if (.not.lgamma) then
                    dervi(mjr+i,mir+j) = dervi(mjr+i,mir+j) + dervi(mjr+i,mis+l)
                  endif
                endif
              endif
            enddo
          enddo
        enddo
      else
!
!  Full occupancy
!
        mis = mint
        mjs = mint
        do i = 1,nbs
          nri = nbsptr(i)
          do j = 1,nbs
            nrj = nbsptr(j)
            derv2(mjs+j,mis+i) = derv2(mjs+nrj,mis+nri)
          enddo
          do j = 1,nphonat
            indj = 3*(j-1)
            indjj = 3*(nphonatptr(j) - 1)
            derv2(indj+1,mis+i) = derv2(indjj+1,mis+nri)
            derv2(indj+2,mis+i) = derv2(indjj+2,mis+nri)
            derv2(indj+3,mis+i) = derv2(indjj+3,mis+nri)
            derv2(mis+i,indj+1) = derv2(mis+nri,indjj+1)
            derv2(mis+i,indj+2) = derv2(mis+nri,indjj+2)
            derv2(mis+i,indj+3) = derv2(mis+nri,indjj+3)
          enddo
          if (.not.lgamma) then
            do j = 1,nbs
              nrj = nbsptr(j)
              dervi(mjs+j,mis+i) = dervi(mjs+nrj,mis+nri)
            enddo
            do j = 1,nphonat
              indj = 3*(j-1)
              indjj = 3*(nphonatptr(j) - 1)
              dervi(indj+1,mis+i) = dervi(indjj+1,mis+nri)
              dervi(indj+2,mis+i) = dervi(indjj+2,mis+nri)
              dervi(indj+3,mis+i) = dervi(indjj+3,mis+nri)
              dervi(mis+i,indj+1) = dervi(mis+nri,indjj+1)
              dervi(mis+i,indj+2) = dervi(mis+nri,indjj+2)
              dervi(mis+i,indj+3) = dervi(mis+nri,indjj+3)
            enddo
          endif
        enddo
      endif
    endif
!**********************************
!  Eliminate shell contributions  *
!**********************************
    if (msv.gt.0) then
      if (lgamma) then
!**************************
!  Real Matrix Inversion  *
!**************************
        t1i = cputime()
        ifail = 0                   
!     
!  Allocate workspace for inversion
!     
        allocate(ipivot(msv),stat=status)
        if (status/=0) call outofmemory('phonon','ipivot')                  
        allocate(w3(3*msv),stat=status)
        if (status/=0) call outofmemory('phonon','w3')
!
!  Transfer data to packed storage
!    
        kk = 0
        do i = 1,msv
          do j = 1,i
            kk = kk + 1
            eigr(kk) = derv2(mcv+j,mcv+i)
          enddo
        enddo                                    
!         
!  Factorise matrix
!  
        call dsptrf('U',msv,eigr,ipivot,ifail)
        if (ifail.eq.0) then
!
!  Form inverse
!
          call dsptri('U',msv,eigr,ipivot,w3,ifail)
!
!  Transfer data back
!
          kk = 0
          do i = 1,msv
            do j = 1,i
              kk = kk + 1
              derv2(mcv+j,mcv+i) = eigr(kk)
              derv2(mcv+i,mcv+j) = eigr(kk)
            enddo
          enddo
        endif
!
!  Free workspace  
!
        deallocate(w3,stat=status)
        if (status/=0) call deallocate_error('phonon','w3')
        deallocate(ipivot,stat=status)
        if (status/=0) call deallocate_error('phonon','ipivot')  
!
        t2i = cputime()
        tmati = tmati + t2i - t1i
        if (ifail.ne.0) then
          call outerror('inversion of shell 2nd derivatives failed',0_i4)
          call stopnow('phonon')
        endif
!***********************************************
!  Corrected second derivatives = R - T*S-1*T  *
!***********************************************
!
!  First pass : S-1*T stored in diagonally opposite copy of T
!
        do i = 1,mcv
          do j = 1,msv
            wr = 0.0_dp
            do l = 1,msv
              wr = wr + derv2(j+mcv,l+mcv)*derv2(i,l+mcv)
            enddo
            derv2(mcv+j,i) = wr
          enddo
        enddo
!
!  Second pass : T*(S-1*T)
!
        do i = 1,mcv
          do j = 1,mcv
            wr = 0.0_dp
            do l = 1,msv
              wr = wr - derv2(j,l+mcv)*derv2(mcv+l,i)
            enddo
            derv2(j,i) = derv2(j,i) + wr
          enddo
        enddo
      else
!*****************************
!  Complex Matrix Inversion  *
!*****************************
!
!  Transfer real and imaginary components to complex matrix 
!
        call phoncopy1(derv2,dervi,eigr,maxd2,mcv,mcv,msv,msv)
!
!  Invert complex matrix
!
        job = 1
        t1i = cputime()
        allocate(kpvt(msv),stat=status)
        if (status/=0) call outofmemory('phonon','kpvt')
        call zhifa(eigr,msv,msv,kpvt,ifail)
        if (ifail.ne.0) then
          call outerror('inversion of shell 2nd derivatives failed',0_i4)
          goto 999
        endif
        allocate(ctmp(msv),stat=status)
        if (status/=0) call outofmemory('phonon','ctmp')
        call zhidi(eigr,msv,msv,kpvt,det,inert,ctmp,job)
        deallocate(ctmp,stat=status)
        if (status/=0) call deallocate_error('phonon','ctmp')
        deallocate(kpvt,stat=status)
        if (status/=0) call deallocate_error('phonon','kpvt')
        t2i = cputime()
        tmati = tmati + t2i - t1i
!
!  Return inverse complex matrix to separate real and imaginary matrices and resymmetrise
!
        call phoncopy2e(derv2,dervi,eigr,maxd2,mcv,mcv,msv,msv)
!***********************************************
!  Corrected second derivatives = R - T*S-1*T  *
!***********************************************
!
!  First pass : S-1*T stored in diagonally opposite copy of T
!
        do i = 1,mcv
          do j = 1,msv
            wr = 0.0_dp
            wi = 0.0_dp
            do l = 1,msv
              wr = wr + derv2(j+mcv,l+mcv)*derv2(i,l+mcv)
              wr = wr + dervi(j+mcv,l+mcv)*dervi(i,l+mcv)
              wi = wi + dervi(j+mcv,l+mcv)*derv2(i,l+mcv)
              wi = wi - derv2(j+mcv,l+mcv)*dervi(i,l+mcv)
            enddo
            derv2(mcv+j,i) = wr
            dervi(mcv+j,i) = wi
          enddo
        enddo
!
!  Second pass : T*(S-1*T) - for imaginary case sign has to be adjusted
!  to allow for the fact that T(conj) and T are of opposite signs
!
        do i = 1,mcv
          do j = 1,mcv
            wr = 0.0_dp
            wi = 0.0_dp
            do l = 1,msv
              wr = wr - derv2(j,l+mcv)*derv2(mcv+l,i)
              wr = wr + dervi(j,l+mcv)*dervi(mcv+l,i)
              wi = wi - derv2(j,l+mcv)*dervi(mcv+l,i)
              wi = wi - dervi(j,l+mcv)*derv2(mcv+l,i)
            enddo
            derv2(j,i) = derv2(j,i) + wr
            dervi(j,i) = dervi(j,i) + wi
          enddo
        enddo
      endif
    endif
!****************************
!  End of shell correction  *
!****************************
!
!  Option to write out a .frc file for QMPOT
!
    if (lfrc.and.ioproc.and.lgamma) call outfrc(fc,.true.,.true.)
!*****************************
!  Multiply by mass-factors  *
!*****************************
    if (lgamma) then
      do ii = 1,3
        indi = ii - 3
        do jj = 1,3
          indj = jj - 3
          do i = 1,ncfoc
            rmassi = rmass(i)
            do j = 1,ncfoc
              derv2(indj+3*j,indi+3*i) = rmassi*rmass(j)*derv2(indj+3*j,indi+3*i)
            enddo
          enddo
        enddo
      enddo
    else
      do ii = 1,3
        indi = ii - 3
        do jj = 1,3
          indj = jj - 3
          do i = 1,ncfoc
            rmassi = rmass(i)
            do j = 1,ncfoc
              derv2(indj+3*j,indi+3*i) = rmassi*rmass(j)*derv2(indj+3*j,indi+3*i)
              dervi(indj+3*j,indi+3*i) = rmassi*rmass(j)*dervi(indj+3*j,indi+3*i)
            enddo
          enddo
        enddo
      enddo
    endif
!
!  If debugging print out dynamical matrix
!
    if (index(keyword,'dynam').ne.0.and.ioproc) then
      write(ioout,'(/,''  Real Dynamical matrix :'',/)')
      do i = 1,mcv
        write(ioout,'(12f11.6)')(derv2(j,i),j=1,mcv)
      enddo
      if (.not.lgamma) then
        write(ioout,'(/,''  Imaginary Dynamical matrix :'',/)')
        do i = 1,mcv
          write(ioout,'(12f11.6)')(dervi(j,i),j=1,mcv)
        enddo
      endif
    endif
!*********************************
!  Diagonalise dynamical matrix  *
!*********************************
    ifail = 0
    if (leigloc) then
!*********************************
!  Eigenvectors and eigenvalues  *
!*********************************
      if (lgamma) then
!
!  Calculate eigenvalues and eigenvectors of uncorrected dynamical matrix
!
        call pdiagg(mcv,maxd2,derv2,eigr,freq(1,k-nlkpt+1),fscale,.true.,lprint,ifail)
!
!  Calculate the oscillator strengths
!
        call oscillatorstrength(mcv,nphonatc,nphonatptr,ncfoc,iocptr,eigr,maxd2,oscstrength)
!
!  Store uncorrected frequencies
!
        savefreq(1:mcv) = freq(1:mcv,k-nlkpt+1)
        if (nbornstep(ncf).eq.0.and.lnonanal) then
!
!  Non-analytic correction for gamma point
!
          if (lnonanal) then
!
!  Find if this point is part of a dispersion curve and if it is substitute direction of approach
!
            lpartofdisp = (nudpt.ge.nldpt)
            if (lpartofdisp) then
              if (k.ge.ndds(nldpt).and.k.le.ndde(nudpt)) then
                lfound = .false.
                nd = nldpt - 1
                do while (.not.lfound.and.nd.lt.nudpt)
                  nd = nd + 1
                  lfound = (k.ge.ndds(nd).and.k.le.ndde(nd))
                enddo
                bornkloc(1) = xkpt(ndde(nd)) - xkpt(ndds(nd))
                bornkloc(2) = ykpt(ndde(nd)) - ykpt(ndds(nd))
                bornkloc(3) = zkpt(ndde(nd)) - zkpt(ndds(nd))
              else
                lpartofdisp = .false.
              endif
            endif
            if (lpartofdisp) then
              call nagamma(ncfoc,nphonatc,iocptr,rmass,bornkloc,maxd2,derv2)
            else
              call nagamma(ncfoc,nphonatc,iocptr,rmass,bornk(1,ncf),maxd2,derv2)
            endif
          endif
!
!  Calculate eigenvalues and eigenvectors of corrected dynamical matrix
!
          call pdiagg(mcv,maxd2,derv2,eigr,freq(1,k-nlkpt+1),fscale,.false.,lprint,ifail)
        elseif (nbornstep(ncf).ne.0) then
!******************************************************
!  Polycrystalline average of gamma point correction  *
!******************************************************
!
!  Allocate extra storage
!
          allocate(averfreq(mcv),stat=status)
          if (status/=0) call outofmemory('phonon','averfreq')
!
!  Store derv2
!
          savederv2(1:mcv,1:mcv) = derv2(1:mcv,1:mcv)
          averfreq(1:mcv) = 0.0_dp
!
!  Set theta and phi step sizes
!
          weightpt = 1.0_dp/dble(nbornstep(ncf))
          phistep = 0.5_dp*pi*weightpt
          thetastep = phistep
!
!  Loop over theta and phi in nbornstep divisions per angle
!
          weightpt = 0.0_dp
          phi = - phistep
          do np = 0,nbornstep(ncf)
            phi = phi + phistep
            theta = - thetastep
            if (np.eq.0) then
              ntmax = 1
            elseif (np.eq.nbornstep(ncf)) then
              ntmax = 2*nbornstep(ncf)
            else
              ntmax = 4*nbornstep(ncf)
            endif
            do nt = 1,ntmax
              theta = theta + thetastep
              weightpt = weightpt + 1.0_dp
!
!  Find current Q direction of approach
!
              qfrac(1) = sin(phi)*cos(theta)
              qfrac(2) = sin(phi)*sin(theta)
              qfrac(3) = cos(phi)
!
!  Restore derv2
!
              derv2(1:mcv,1:mcv) = savederv2(1:mcv,1:mcv)
!
!  Non-analytic correction for gamma point
!
              call nagamma(ncfoc,nphonatc,iocptr,rmass,qfrac,maxd2,derv2)
!
!  Calculate eigenvalues and eigenvectors of corrected dynamical matrix
!
              call pdiagg(mcv,maxd2,derv2,eigr(maxd2*maxd2+1),freq(1,k-nlkpt+1),fscale,.true.,lprint,ifail)
!
!  Find correspondence of modes by projection of eigenvectors
!

!
!  Add frequencies to average for appropriate mode
!
              do nf = 1,mcv
                averfreq(nf) = averfreq(nf) + freq(nf,k-nlkpt+1)
              enddo
!
!  End loops over angles
!
            enddo
          enddo
!
!  Move average frequencies back to main frequency array
!
          freq(1:mcv,k-nlkpt+1) = averfreq(1:mcv)/weightpt
!
          deallocate(averfreq,stat=status)
          if (status/=0) call deallocate_error('phonon','averfreq')
        endif
!
!  Output frequencies / DOS / intensities
!
        call peigeng(mcv,freq(1,k-nlkpt+1),ncore,nphonatc,ncfoc,iocptr,maxd2,eigr,leig)
        if (nobsmode.gt.0) then
!
!  Look for vibrational mode frequencies projected on to eigenvectors
!
          do nobm = 1,nobsmode
            call getvibmode(nobsmodeptr0+nobm,maxd2,eigr,nfitmode)
            fobsmodefreq(nobsmodeptr0+nobm) = freq(nfitmode,k-nlkpt+1)
          enddo
        endif
!
!  Thermal conductivity calculation
!
        if (lthermal) then
          call thermalconductivity(mcv,derv2,eigr,Sij,freq(1,k-nlkpt+1),nphonatc,ncfoc,nphonatptr,maxd2)
        endif
!
!  Lower symmetry to remove imaginary modes if selected
!
        call lower(mcv,freq(1,k-nlkpt+1),nphonatc,nphonatptr,ncfoc,iocptr,maxd2,eigr)
      else
!
!  Calculate eigenvalues and eigenvectors of dynamical matrix
!
        if (leispack_eigensolve) then
          call pdiage(mcv,maxd2,derv2,dervi,eigr(1),eigr(maxd2*maxd2+1),freq(1,k-nlkpt+1),fscale,.true.,lprint,ifail)
        else
          call pdiagl(mcv,maxd2,derv2,dervi,eigr(1),eigr(maxd2*maxd2+1),freq(1,k-nlkpt+1),fscale,.true.,lprint,ifail)
        endif
!
!  Output frequencies / DOS / intensities
!
        call peigen(mcv,freq(1,k-nlkpt+1),ncore,nphonatc,ncfoc,nsfoc,iocptr,maxd2,eigr(1),eigr(maxd2*maxd2+1),leig) 
!
!  Lower symmetry to remove imaginary modes if selected
!
        call lower(mcv,freq(1,k-nlkpt+1),nphonatc,nphonatptr,ncfoc,iocptr,maxd2,eigr)
      endif
    else
!*********************
!  Eigenvalues only  *
!*********************
      if (lgamma) then
!
!  Non-analytic correction for gamma point
!
        if (lnonanal) then
!
!  Find if this point is part of a dispersion curve and if it is substitute direction of approach
!
          lpartofdisp = (nudpt.ge.nldpt)
          if (lpartofdisp) then
            if (k.ge.ndds(nldpt).and.k.le.ndde(nudpt)) then
              lfound = .false.
              nd = nldpt - 1
              do while (.not.lfound.and.nd.lt.nudpt)
                nd = nd + 1
                lfound = (k.ge.ndds(nd).and.k.le.ndde(nd))
              enddo
              bornkloc(1) = xkpt(ndde(nd)) - xkpt(ndds(nd))
              bornkloc(2) = ykpt(ndde(nd)) - ykpt(ndds(nd))
              bornkloc(3) = zkpt(ndde(nd)) - zkpt(ndds(nd))
            else
              lpartofdisp = .false. 
            endif
          endif
          if (lpartofdisp) then
            call nagamma(ncfoc,nphonatc,iocptr,rmass,bornkloc,maxd2,derv2)
          else
            call nagamma(ncfoc,nphonatc,iocptr,rmass,bornk(1,ncf),maxd2,derv2)
          endif
        endif
!
!  Calculate eigenvalues of uncorrected dynamical matrix
!
        call pdiagg(mcv,maxd2,derv2,eigr,freq(1,k-nlkpt+1),fscale,.false.,lprint,ifail)
      else
!
!  Calculate eigenvalues of dynamical matrix
!
        if (leispack_eigensolve) then
          call pdiage(mcv,maxd2,derv2,dervi,eigr,eigr,freq(1,k-nlkpt+1),fscale,.false.,lprint,ifail)
        else
          call pdiagl(mcv,maxd2,derv2,dervi,eigr,eigr,freq(1,k-nlkpt+1),fscale,.false.,lprint,ifail)
        endif
      endif
!
!  Output frequencies
!
      if (lfreqout.and.lprinloc) then
        write(ioout,'(/,''  Frequencies (cm-1) [NB: Negative implies an imaginary mode]:'',/)')
        write(ioout,'(9f8.2)')(freq(i,k-nlkpt+1),i=1,mcv)
        write(ioout,'(/)')
      endif
    endif
!
!  Store frequencies if needed for output options
!
    if (ldendisp.or.(lfrq.and.lfrqbin).or.ltemprop.or.(lprinloc.and.(ntemperaturestep.gt.0))) then
      t1 = cputime()
      if (lfrq.and.ioproc) then
        if (lfrqbin) then
          do i = 1,mcv
            write(51) freq(i,k-nlkpt+1)
          enddo
        else
          do i = 1,mcv
            write(52,'(f12.6)') freq(i,k-nlkpt+1)
          enddo
        endif
      endif
      t2 = cputime()
      tdisk = tdisk + t2 - t1
    elseif (lfrq.and.ioproc) then
      t1 = cputime()
      do i = 1,mcv
        write(52,'(f12.6)') freq(i,k-nlkpt+1)
      enddo
      t2 = cputime()
      tdisk = tdisk + t2 - t1
    endif
!***************************************
!  Evaluate phonon related properties  *
!***************************************
    if (ntemperaturestep.eq.0) then
      if (temperature.gt.1.0d-6) then
        allocate(w1(mcv),stat=status)
        if (status/=0) call outofmemory('phonon','w1')
        allocate(w2(mcv),stat=status)
        if (status/=0) call outofmemory('phonon','w2')
        allocate(w3(mcv),stat=status)
        if (status/=0) call outofmemory('phonon','w3')
!
!  Scale frequencies to hw/kT
!
        cmfact = planck*speedl/rkt
        do i = 1,mcv
          freq(i,k-nlkpt+1) = cmfact*freq(i,k-nlkpt+1)
        enddo
!
!  Store exp(x) in w1, exp(x)-1 in w2 and 1/(exp(x)-1) in w3
!
        do i = 1,mcv
          if (freq(i,k-nlkpt+1).lt.12.0_dp) then
            w1(i) = exp(freq(i,k-nlkpt+1))
            w2(i) = w1(i) - 1.0_dp
            if (abs(w2(i)).gt.0.0_dp) w3(i) = 1.0_dp/w2(i)
          else
            w1(i) = exp(-freq(i,k-nlkpt+1))
            w3(i) = exp(-freq(i,k-nlkpt+1))
          endif
        enddo
!
!  Zero point energy
!
        factor = 0.5_dp*wk*rkt/evtoj
        trmzp = 0.0_dp
        do i = 1,mcv
          if (freq(i,k-nlkpt+1).gt.cmfact) trmzp = trmzp + freq(i,k-nlkpt+1)
        enddo
        trmzp = factor*trmzp
!
!  Kinetic energy
!
        do i = 1,mcv
          kinenergy = kinenergy + factor*freq(i,k-nlkpt+1)*(0.5_dp + w3(i))
        enddo
        if (lmeanke) then
!
!  Aportion kinetic energy to atoms based on eigenvector contribution
!
          do i = 1,mcv
            trmke = factor*freq(i,k-nlkpt+1)*(0.5_dp + w3(i))
            do j = 1,mcv
              jj = (j-1)/3_i4 + 1
              if (lgamma) then
                projectionfactor = eigr(maxd2*(i-1)+j)**2
              else
                eigreal = eigr(maxd2*(i-1)+j)
                eigcomp = eigr(maxd2*maxd2+maxd2*(i-1)+j)
                projectionfactor = eigreal**2 + eigcomp**2
              endif
              meanKEperatom(jj) = meanKEperatom(jj) + trmke*projectionfactor
            enddo
          enddo
        endif
!
!  Entropy and free energy
!
        trmfe = 0.0_dp
        trmen = 0.0_dp
        freqmin = cmfact
        do i = 1,mcv
          trm1 = freq(i,k-nlkpt+1)
          if (trm1.gt.freqmin) then
            trm1 = 1.0_dp - exp(-trm1)
            trmfe = trmfe + log(trm1)
            trmen = trmen + freq(i,k-nlkpt+1)*w3(i)
          endif
        enddo
!
!  Equipartition free energy
!
        trmfe_eq = 0.0_dp
        rmode = 0.0_dp
        do i = 1,mcv
          trm1 = freq(i,k-nlkpt+1)
          if (trm1.gt.freqmin) then
            trmfe_eq = trmfe_eq + log(trm1) - 1.0_dp
            rmode = rmode + 1.0_dp
          endif
        enddo
!
        factor = 2.0_dp*factor
        trm = factor*trmfe
        if (lnozero) then
          fhenergy = fhenergy + trm 
        else
          fhenergy = fhenergy + trm + trmzp
          zpe = zpe + trmzp
        endif
        rtlnz = rtlnz - trm
        factor = factor/temperature
        entropy = entropy + factor*trmen
        fentropy = fentropy + factor*(trmen - trmfe)
        finternal = finternal + factor*trmen*temperature
        fe_equipartition = fe_equipartition + wk*trmfe_eq
!
!  Heat capacity - constant volume
!
        trmcv = 0.0_dp
        do i = 1,mcv
          if (freq(i,k-nlkpt+1).gt.freqmin) then
            if (freq(i,k-nlkpt+1).lt.12.0_dp) then
              trmcv = trmcv + (freq(i,k-nlkpt+1)**2)*w1(i)*w3(i)*w3(i)
            else
              trmcv = trmcv + (freq(i,k-nlkpt+1)**2)*w3(i)
            endif
          endif
        enddo
        cv = cv + factor*trmcv
!
!  Scale frequencies back to wavenumbers for fitting
!
        do i = 1,mcv
          freq(i,k-nlkpt+1) = freq(i,k-nlkpt+1)/cmfact
        enddo
        deallocate(w1,stat=status)
        if (status/=0) call deallocate_error('phonon','w1')
        deallocate(w2,stat=status)
        if (status/=0) call deallocate_error('phonon','w2')
        deallocate(w3,stat=status)
        if (status/=0) call deallocate_error('phonon','w3')
      elseif (.not.lnozero) then
!
!  Zero point energy
!
        factor = 0.5_dp*wk*planck*speedl/evtoj
        trmzp = 0.0_dp
        do i = 1,mcv
          if (freq(i,k-nlkpt+1).gt.1.0_dp) trmzp = trmzp + freq(i,k-nlkpt+1)
        enddo
        trmzp = factor*trmzp
        zpe = zpe + trmzp
      endif
    endif
!
!  Output eigenvectors if requested
!
    if (lfreqout.and.lprinloc) then
      write(ioout,'(''--------------------------------------------------------------------------------'')')
    endif
!
!  Frequency-dependent properties
!
    if (lomega(ncf).and.lgamma) then
      call omegaproperty(mcv,savefreq,fscale,oscstrength)
    endif
!***************************
!  End loop over K points  *
!***************************
  enddo
  if (lpdf) then
!
!  Set up variables for gulp_cml_PDFstats
!
    call pdfsetup(lcml) 
  endif
!**************************************************
!  Deallocate second derivative workspace memory  *
!**************************************************
  deallocate(eigr,stat=status)
  if (status/=0) call deallocate_error('phonon','eigr')
  if (allocated(savederv2)) then
    deallocate(savederv2,stat=status)
    if (status/=0) call deallocate_error('phonon','savederv2')
  endif
!*************************************
!  Output phonon related properties  *
!*************************************
  if (lprinloc) then
    if (ntemperaturestep.gt.0) then
      allocate(rtmp2(mcv),stat=status)
      if (status/=0) call outofmemory('phonon','rtmp2')
      allocate(w1(mcv),stat=status)
      if (status/=0) call outofmemory('phonon','w1')
      allocate(w2(mcv),stat=status)
      if (status/=0) call outofmemory('phonon','w2')
      allocate(w3(mcv),stat=status)
      if (status/=0) call outofmemory('phonon','w3')
      tem = temperature - temperaturestep
      do nt = 0,ntemperaturestep
        tem = tem + temperaturestep
!***************************************
!  Evaluate phonon related properties  *
!***************************************
!
!  Initialise thermodynamic properties
!
        zpe = 0.0_dp
        entropy = 0.0_dp
        fhenergy = 0.0_dp
        kinenergy = 0.0_dp
        rtlnz = 0.0_dp
        cv = 0.0_dp
        fe_equipartition = 0.0_dp
        rkt = boltz*tem
        cmfact = planck*speedl/rkt
!
!  Loop over K points
!
        do nk = 1,nllkpt
          wk = wkpt(nlkpt+nk-1)*rnokpt
          if (tem.gt.1.0d-6) then
!
!  Scale frequencies to hw/kT
!
            do i = 1,mcv
              rtmp2(i) = cmfact*freq(i,nk-nlkpt+1)
            enddo
!
!  Store exp(x) in w1, exp(x)-1 in w2 and 1/(exp(x)-1) in w3
!
            do i = 1,mcv
              if (rtmp2(i).lt.12.0_dp) then
                w1(i) = exp(rtmp2(i))
                w2(i) = w1(i) - 1.0_dp
                if (abs(w2(i)).gt.0.0_dp) w3(i) = 1.0_dp/w2(i)
              else
                w1(i) = exp(-rtmp2(i))
                w3(i) = exp(-rtmp2(i))
              endif
            enddo
!
!  Zero point energy
!
            factor = 0.5_dp*wk*rkt/evtoj
            trmzp = 0.0_dp
            do i = 1,mcv
              if (rtmp2(i).gt.cmfact) trmzp = trmzp + rtmp2(i)
            enddo
            trmzp = factor*trmzp
!
!  Kinetic energy
!
            do i = 1,mcv
              kinenergy = kinenergy + factor*rtmp2(i)*(0.5_dp + w3(i))
            enddo
!
!  Entropy and free energy
!
            trmfe = 0.0_dp
            trmen = 0.0_dp
            freqmin = cmfact
            do i = 1,mcv
              trm1 = rtmp2(i)
              if (trm1.gt.freqmin) then
                trm1 = 1.0_dp - exp(-trm1)
                trmfe = trmfe + log(trm1)
                trmen = trmen + rtmp2(i)*w3(i)
              endif
            enddo
!
!  Equipartition free energy
!
            trmfe_eq = 0.0_dp
            rmode = 0.0_dp
            do i = 1,mcv
              trm1 = freq(i,nk-nlkpt+1)
              if (trm1.gt.freqmin) then
                trmfe_eq = trmfe_eq + log(trm1) - 1.0_dp
                rmode = rmode + 1.0_dp
              endif
            enddo
!
            factor = 2.0_dp*factor
            trm = factor*trmfe
            if (lnozero) then
              fhenergy = fhenergy + trm 
            else
              fhenergy = fhenergy + trm + trmzp
              zpe = zpe + trmzp
            endif
            rtlnz = rtlnz - trm
            factor = factor/tem
            entropy = entropy + factor*trmen
            fe_equipartition = fe_equipartition + wk*trmfe_eq
!
!  Heat capacity - constant volume
!
            trmcv = 0.0_dp
            do i = 1,mcv
              if (rtmp2(i).gt.freqmin) then
                if (rtmp2(i).lt.12.0_dp) then
                  trmcv = trmcv + rtmp2(i)*rtmp2(i)*w1(i)*w3(i)*w3(i)
                else
                  trmcv = trmcv + rtmp2(i)*rtmp2(i)*w3(i)
                endif
              endif
            enddo
            cv = cv + factor*trmcv
          elseif (.not.lnozero) then
!
!  Zero point energy
!
            factor = 0.5_dp*wk*planck*speedl/evtoj
            trmzp = 0.0_dp
            do i = 1,mcv
              if (freq(i,nk-nlkpt+1).gt.1.0_dp) trmzp = trmzp + freq(i,nk-nlkpt+1)
            enddo
            trmzp = factor*trmzp
            zpe = zpe + trmzp
          endif
!
!  End of loop over K points
!
        enddo
        write(ioout,'(''  Phonon properties (per mole of unit cells): Temperature = '',f10.3,'' K'')') tem
        write(ioout,'(''--------------------------------------------------------------------------------'')')
        write(ioout,'(''  Zero point energy            = '',f15.6,'' eV'')') zpe
        if (tem.gt.1.0d-03) then
          trmen = fhenergy - zpe
          entropy = entropy - trmen/tem
          ent2 = entropy*evtoj*avogadro
          cv2 = cv*evtoj*avogadro
          write(ioout,'(''  Entropy                      = '',f15.6,'' eV/K'')') entropy
          write(ioout,'(''                               = '',f15.6,'' J/(mol.K)'')') ent2
          write(ioout,'(''  Helmholtz free-energy        = '',f15.6,'' eV'')') fhenergy+fc
          write(ioout,'(''                               = '',f15.6,'' kJmol-1'')') (fhenergy+fc)*evtoj*avogadro*0.001_dp
          write(ioout,'(''  Free energy (equipartition)  = '',f15.6,'' eV'')') fc + (fe_equipartition + rmode)*rkt/evtoj 
          write(ioout,'(''  - T*S       (equipartition)  = '',f15.6,'' eV'')') fe_equipartition*rkt/evtoj
          write(ioout,'(''  Uvib        (equipartition)  = '',f15.6,'' eV'')') rmode*rkt/evtoj
          write(ioout,'(''  Mean kinetic energy          = '',f15.6,'' eV'')') kinenergy
          write(ioout,'(''  Heat capacity - const volume = '',f15.6,'' eV/K'')') cv
          write(ioout,'(''                               = '',f15.6,'' J/(mol.K)'')') cv2
        endif
        write(ioout,'(''--------------------------------------------------------------------------------'')')
      enddo
      deallocate(rtmp2,stat=status)
      if (status/=0) call deallocate_error('phonon','rtmp2')
      deallocate(w1,stat=status)
      if (status/=0) call deallocate_error('phonon','w1')
      deallocate(w2,stat=status)
      if (status/=0) call deallocate_error('phonon','w2')
      deallocate(w3,stat=status)
      if (status/=0) call deallocate_error('phonon','w3')
    else
      write(ioout,'(''  Phonon properties (per mole of unit cells): Temperature = '',f10.3,'' K'')')temperature
      write(ioout,'(''--------------------------------------------------------------------------------'')')
      write(ioout,'(''  Zero point energy            = '',f15.6,'' eV'')') zpe
      if (temperature.gt.1.0d-03) then
        trmen = fhenergy - zpe
        entropy = entropy - trmen/temperature
        ent2 = entropy*evtoj*avogadro
        cv2 = cv*evtoj*avogadro
        write(ioout,'(''  Entropy                      = '',f15.6,'' eV/K'')') entropy
        write(ioout,'(''                               = '',f15.6,'' J/(mol.K)'')') ent2
        write(ioout,'(''  Helmholtz free-energy        = '',f15.6,'' eV'')') fhenergy + fc
        write(ioout,'(''                               = '',f15.6,'' kJmol-1'')') (fhenergy+fc)*evtoj*avogadro*0.001_dp
        write(ioout,'(''  Free energy (equipartition)  = '',f15.6,'' eV'')') fc + (fe_equipartition + rmode)*rkt/evtoj
        write(ioout,'(''  - T*S       (equipartition)  = '',f15.6,'' eV'')') fe_equipartition*rkt/evtoj
        write(ioout,'(''  Uvib        (equipartition)  = '',f15.6,'' eV'')') rmode*rkt/evtoj
        write(ioout,'(''  Mean kinetic energy          = '',f15.6,'' eV'')') kinenergy
        write(ioout,'(''  Heat capacity - const volume = '',f15.6,'' eV/K'')') cv
        write(ioout,'(''                               = '',f15.6,'' J/(mol.K)'')') cv2
      endif
      write(ioout,'(''--------------------------------------------------------------------------------'')')
      if (lmeanke) then
        write(ioout,'(''  Mean kinetic energy per site: (eV)'')')
        write(ioout,'(''--------------------------------------------------------------------------------'')')
        do i = 1,ncfoc
          write(ioout,'(i6,2x,f15.6)') i,meanKEperatom(i)
        enddo
        write(ioout,'(''--------------------------------------------------------------------------------'')')
      endif
    endif
  endif
!
!  If output if required then call outphon
!
  if (ldendisp.and.ioproc) then
    call outphon(nlkpt,nukpt,leigloc,freq,ncfoc)
    if (lfrq.and.lfrqbin) close(51)
  elseif (lfrq.and.lfrqbin.and.ioproc) then
    close(51)
  endif
!***************
!  Exit point  *
!***************
999 continue
!
!  Close I/O channels
!
  if (leig.and.ioproc) then
    close(53)
  endif
!
!  CML output
!
  if (lcmlloc) call gulp_cml_endPhonons
  if (lcml.and.lpdf) then
    call gulp_cml_PDFstats
    call gulp_cml_outPDF
  endif
!
!  Free local memory
!
  if (lthermal) then
    deallocate(Sij,stat=status)
    if (status/=0) call deallocate_error('phonon','Sij')
  endif
  if (leigloc) then
    deallocate(oscstrength,stat=status)
    if (status/=0) call deallocate_error('phonon','oscstrength')
    deallocate(savefreq,stat=status)
    if (status/=0) call deallocate_error('phonon','savefreq')
  endif
  if (allocated(kpvt)) then
    deallocate(kpvt,stat=status)
    if (status/=0) call deallocate_error('phonon','kpvt')
  endif
  deallocate(meanKEperatom,stat=status)
  if (status/=0) call deallocate_error('phonon','meanKEperatom')
  deallocate(nphonatptr,stat=status)
  if (status/=0) call deallocate_error('phonon','nphonatptr')
!
!  Close PDF related parts of phonon 
!
  call closepdfphonon
!
!  Timing
!
  t2t = cputime()
  tphon = t2t - t1t + tphon
!
  return
  end
